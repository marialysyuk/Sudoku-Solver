# -*- coding: utf-8 -*-
"""Sudoku Submission.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WnLqvfEI8QUfcukE_WNVFE4D53NtZEaG
"""

#import joblib

import numpy as np
from numpy import logical_and as land
from numpy import logical_not as lnot
from skimage.feature import canny
from skimage.transform import rescale, ProjectiveTransform, warp
from skimage.morphology import dilation, disk
import cv2
from imutils.perspective import four_point_transform
from skimage.segmentation import clear_border
from tensorflow import keras
import imutils
from tensorflow.keras.preprocessing.image import img_to_array

SCALE = 0.33

def digit_mask(cell):

  thresh = cv2.threshold(cell, 0, 255, 
                         cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]
  thresh = clear_border(thresh)
 
  cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL,
                          cv2.CHAIN_APPROX_SIMPLE)
  cnts = imutils.grab_contours(cnts)
	
  if len(cnts) == 0:
    return None
  
  c = max(cnts, key = cv2.contourArea)
  mask = np.zeros(thresh.shape, dtype = "uint8")
  cv2.drawContours(mask, [c], -1, 255, -1)

  (h, w) = thresh.shape
  percentFilled = cv2.countNonZero(mask) / float(w * h)

  if percentFilled < 0.03:
    return None

  digit = cv2.bitwise_and(thresh, thresh, mask=mask)

  return digit

def find_grid(warped, model):
 
  cells = []
  grid = np.full((9, 9), -1)
  step_x = warped.shape[1] // 9
  step_y = warped.shape[0] // 9
  
  for y in range(0, 9):
    row = []
    for x in range(0, 9):
      start_x = x * step_x
      start_y = y * step_y
      end_x = (x + 1) * step_x
      end_y = (y + 1) * step_y
      row.append((start_x, start_y, end_x, end_y))

      cell = warped[start_y:end_y, start_x:end_x]
      digit = digit_mask(cell)

      if digit is not None:
        roi = cv2.resize(digit, (28, 28))
        roi = roi.astype("float") / 255.0
        roi = img_to_array(roi)
        roi = np.expand_dims(roi, axis=0)
        pred = model.predict(roi).argmax(axis=1)[0]
        grid[y, x] = pred
    cells.append(row)
  return grid

def predict_digits(image):
  
  img = cv2.cvtColor(image,cv2.COLOR_BGR2RGB)
  gray = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)

  mask = np.zeros((gray.shape),np.uint8)

  th2 = cv2.adaptiveThreshold(gray,255,cv2.ADAPTIVE_THRESH_MEAN_C,\
            cv2.THRESH_BINARY_INV,39,10)

  contours,heirarchy = cv2.findContours(th2,cv2.RETR_EXTERNAL,
                                        cv2.CHAIN_APPROX_SIMPLE)
  warps = []
  areas = []
  flag = 0
  for i in range(len(contours)):
      area = cv2.contourArea(contours[i])
      if area > 600000:
        areas.append([area, i])

  areas.sort(reverse = True)

  cv2.drawContours(mask,[contours[areas[0][1]]],-1,(255,255,255),2)
  
  try:
      peri = cv2.arcLength(contours[areas[0][1]], True)
      approx = cv2.approxPolyDP(contours[areas[0][1]], 0.02 * peri, True)
      warped = four_point_transform(gray, approx.reshape(4, 2))
      warps.append(warped)
  except:
      warps.append(gray)
      flag = 1
      

  for i in range(1,len(areas)):
    if areas[i][0] > 0.5*areas[0][0]:
      cv2.drawContours(mask,[contours[areas[i][1]]],-1,(255,255,255),2)
      try:
          peri = cv2.arcLength(contours[areas[i][1]], True)
          approx = cv2.approxPolyDP(contours[areas[i][1]], 0.02 * peri, True)
          warped = four_point_transform(gray, approx.reshape(4, 2))
          warps.append(warped)
      except:
          warps.append(gray)
          flag = 1

  return warps, flag

def predict_image(image):

    sudokus = predict_digits(image)[0]
    flag = predict_digits(image)[1]
    model = keras.models.load_model('/autograder/submission/model.h5')
    
    if flag == 0:
        digits = []
        for sudoku in sudokus:
            sudoku_digits = np.int16(find_grid(sudoku, model))
            digits.append(sudoku_digits)
    else:
        digits = [
            np.int16([[-1, -1, -1, -1, -1, -1, -1, -1, -1],
                      [-1, -1, -1, -1, -1, -1, -1, -1, -1],
                      [-1, -1, -1, -1, -1, -1, -1, -1, -1],
                      [-1, -1, -1, -1, -1, -1, -1, -1, -1],
                      [-1, -1, -1, -1, -1, -1, -1, -1, -1],
                      [-1, -1, -1, -1, -1, -1, -1, -1, -1],
                      [-1, -1, -1, -1, -1, -1, -1, -1, -1],
                      [-1, -1, -1, -1, -1, -1, -1, -1, -1],
                      [-1, -1, -1, -1, -1, -1, -1, -1, -1]]),
        ]

    img = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
    mask = np.zeros((gray.shape), np.uint8)

    th2 = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, \
                                cv2.THRESH_BINARY_INV, 39, 10)

    contours, heirarchy = cv2.findContours(th2, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    areas = []

    for i in range(len(contours)):
        area = cv2.contourArea(contours[i])
        if area > 600000:
            areas.append([area, i])

    areas.sort(reverse=True)

    cv2.drawContours(mask, [contours[areas[0][1]]], 0, 255, -1)

    for i in range(1, len(areas)):
        if areas[i][0] > 0.5 * areas[0][0]:
            cv2.drawContours(mask, [contours[areas[i][1]]], 0, 255, -1)
    mask = mask.astype(np.bool)
    
    return mask, digits